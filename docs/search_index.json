[["index.html", "Optimized analytical workflow for single-nucleus transcriptomics in main metabolic tissues 1 Introduction", " Optimized analytical workflow for single-nucleus transcriptomics in main metabolic tissues Pengwei Dong 2024-11-21 1 Introduction This is a benchmarked and optimized workflow for analyzing single-nuclei RNA sequencing (snRNA-seq), tailored to the analysis of metabolically active tissues. This workflow includes key steps from preprocessing to downstream analyses. This technical note aims to serve as a standard protocol for researchers seeking to apply snRNA-seq to metabolic tissues including adipose tissue, muscle, hypothalamus and liver to uncover novel regulatory mechanisms, identify new therapeutic targets, and ultimately contribute to the development of more effective treatments for metabolic disorders. This workflow encompasses a series of procedures, including the alignment and quantification of raw FASTQ files, followed by the recommended removal of ambient RNA after generating the raw matrix. Additionally, it involves the potential identification and removal of doublets using scDblFinder, normalization of gene expression values, multiple approaches for data integration, and comprehensive benchmarking steps to ensure robust results. Citation: Dong et al, An optimized practice for upstream analysis of single nucleus transcriptomics in key metabolic tissues "],["genome-alignment-and-quantification.html", "2 Genome alignment and quantification 2.1 Installation and reference downloading 2.2 Usage 2.3 More information", " 2 Genome alignment and quantification Raw single nucleus transcriptomics sequencing reads in fastq format were downloaded and processed with Cell Ranger (version 7.1.0, 10x Genomics) with enabled intron mode for each sample, the reads were aligned to the human GRCh38 genome-2020-A and mouse samples to mm10-2020-A genome to generate unique molecular identifiers (UMIs) the expression matrices. The cellranger count pipeline aligns sequencing reads in FASTQ files to a reference transcriptome and generates gene expresstion matrices. Below is an example from two samples, one is from human adipose tissue datasets, and the other is from mouse muscle datasets. 2.1 Installation and reference downloading We installed Cellranger (v7.1.0) in a dedicated conda environment by following the installation protocol provided by the developers, and the necessary reference files were also downloaded. Ensure that you have download the appropriate reference genome or transcriptome for your analysis. For detailed instructions, please refer to the official documentation: https://www.10xgenomics.com/cn/support/software/cell-ranger/downloads. 2.2 Usage 2.2.1 Getting started First, activate the own conda enviroment of Cell Ranger: (base)$ conda activate cellranger_7 2.2.2 Run cellranger count For human samples: (cellranger_7)$ cellranger count --id=demo \\ --transcriptome=~/cellranger_ref/refdata-gex-GRCh38-2020-A \\ --fastqs=../data/demo \\ --localcores=8 \\ --localmem=64 For mouse samples: (cellranger_7)$ cellranger count --id=demo \\ --transcriptome=~/cellranger_ref/refdata-gex-mm10-2020-A\\ --fastqs=../data/demo \\ --localcores=8 \\ --localmem=64 (The name demo can be replaced with a object name of choice.) 2.2.3 Recommendation for setting arguments The –fastqs argument should specify the path to the directory containing the FASTQ files. If you used cellranger mkfastq to demultiplex your data, you can provide the path to the fastq_path directory located in the pipeline’s outs folder. While it is not necessary for this tutorial, as all FASTQ files come from the same sample, it is included here as an example. Lastly, you need to provide the path to the –transcriptome reference package. Be sure to update the file paths in the following command as needed. 2.3 More information If you want to get more information, please refer to the official website: https://www.10xgenomics.com/cn/support/software/cell-ranger/latest/tutorials/cr-tutorial-ct "],["ambient-rna-removal.html", "3 Ambient RNA removal 3.1 Usage 3.2 Caveats and hints 3.3 More information", " 3 Ambient RNA removal The cell suspension in single nucleus transcriptome sequencing often contains a low-to-moderate concentration of cell-free mRNA or other capturable features, leading to nonzero molecule counts in cell-free droplets. These ‘ambient’ molecules originate from sources such as ruptured or degraded cells, residual cytoplasmic debris (e.g., in snRNA-seq), or exogenous contaminants. This systematic background noise can introduce batch effects and result in spurious differential gene expression. To address this, we apply CellBender, a deep generative model that accurately distinguishes cell-containing droplets from cell-free ones. By learning the background noise profile, it provides end-to-end, noise-free quantification, enhancing the reliability of downstream analysis. The primary module in the current version of CellBender is remove-background. This module effectively eliminates counts attributed to ambient RNA molecules and random barcode swapping from raw UMI-based scRNA-seq gene-by-cell count matrices. It is recommended to run remove-background as a pre-processing step before any downstream analysis using tools such as Seurat, scanpy, or custom analysis pipelines. The module supports several file formats for count matrices, including: Raw .h5 files generated by the cellranger count pipeline The raw_feature_bc_matrix folder produced by cellranger count pipline 3.1 Usage In this project, we utilize CellBender (version 0.3.0) to process the raw_feature_bc_matrix, removing empty droplets and ambient RNA molecule counts from the count matrices, and estimating the true cells present. Below is an example from one sample from adipose tissue datasets. 3.1.1 Installation We installed CellBender (v0.3.0) in a dedicated conda environment by following the installation protocol provided by the developers. You can find the detailed instructions on the documentation: https://cellbender.readthedocs.io/en/v0.3.0/installation/index.html. 3.1.2 Getting started First, activate the own conda enviroment of CellBender: (base)$ conda activate cellbender-env Then, run cellbender remove-backage using the command(leave out the flag –cuda if you are not using a GPU): (cellbender-env)$ cellbender remove-background \\ --input ./raw_feature_bc_matrix.h5 \\ --output ./output/demo.h5 \\ --cuda (The output filename “demo.h5” can be replaced with a filename of choice.) The output of remove-background is a new .h5 count matrix with ambient RNA removed. This matrix can be directly used in downstream analyses with tools like Seurat or scanpy, just as if it were the original raw dataset. You can then proceed with per-cell quality control checks and filter out dead or dying cells, as appropriate for your experiment. 3.2 Caveats and hints 3.2.1 Main output files output_report.html: An HTML report that includes plots, commentary, and any warnings or suggestions for improving parameter settings. output.h5: A full count matrix in .h5 format with background RNA removed, retaining all the original droplet barcodes. output.pdf: A PDF file providing a graphical summary of the inference procedure. 3.2.2 Recommendation for setting arguments As of v0.3.0, users will typically not need to set values for –expected-cells or –total-droplets-included, as CellBender will choose reasonable values based on your dataset. If something goes wrong with these defaults, then you can try to input these arguments manually. Considerations for setting parameters(from the official documentation): –epochs: 150 is typically a good choice. Look for a reasonably-converged ELBO value in the output PDF learning curve (meaning it looks like it has reached some saturating value). Though it may be tempting to train for more epochs, it is not advisable to over-train, since this increases the likelihood of over-fitting. (We regularize to prevent over-fitting, but training for more than 300 epochs is too much.) –expected-cells: Base this on either the number of cells expected a priori from the experimental design, or if this is not known, base this number on the UMI curve as shown below, where the appropriate number would be 5000. Pick a number where you are reasonably sure that all droplets to the left on the UMI curve are real cells. –total-droplets-included: Choose a number that goes a few thousand barcodes into the “empty droplet plateau”. Include some droplets that you think are surely empty. But be aware that the larger this number, the longer the algorithm takes to run (linear). See the UMI curve below, where an appropriate choice would be 15,000. Every droplet to the right of this number on the UMI curve should be surely-empty. (This kind of UMI curve can be seen in the web_summary.html output from cellranger count.) –cuda: Include this flag. The code is meant to be run on a GPU. –learning-rate: The default value of 1e-4 is typically fine, but this value can be adjusted if problems arise during quality-control checks of the learning curve (as above). –fpr: A value of 0.01 is the default, and represents a fairly conservative setting, which is appropriate for most analyses. In order to examine a single dataset at a time and remove more noise (at the expense of some signal), choose larger values such as 0.05 or 0.1. Bear in mind that the value 1 represents removal of (nearly) every count in the dataset, signal and noise. You can generate multiple output count matrices in the same run by choosing several values: 0.0 0.01 0.05 0.1. 3.3 More information If you want to get more information, please refer to the documentation and GitHub: https://cellbender.readthedocs.io/en/v0.3.0/index.html https://github.com/broadinstitute/CellBender/tree/v0.3.0 "],["quality-control-and-doublet-removal.html", "4 Quality control and doublet removal 4.1 Library necessary packages 4.2 Setup the Seurat object 4.3 Dection and handling of doublets/multiplets 4.4 Quality control and selecting cells for further analysis", " 4 Quality control and doublet removal These individual samples from publicly available datasets were re-analyzed with Seurat (version 5.1.0) in R v4.3.1. Individual objects were created considering genes expressed in more than 3 cells, and cells with more than 200 genes expressed. Low-quality barcodes (nucleus) had less than 200 features or than 500 UMIs were excluded. Additionally, Mitochondrial content thresholds for exclusion were set at 5% (hypothalamus, adipose tissue and liver) and 10% (skeletal muscle). All samples were assessed for potential doublets using scDblFinder (version 1.16.0), and nucleus called as doublets were removed before further analyses. 4.1 Library necessary packages library(Seurat) library(dplyr) library(patchwork) library(purrr) library(tidyverse) library(rtracklayer) library(Matrix) library(scDblFinder) Loading output count matrix from CellBender source(&#39;./data/DemoSingle/ReadCB_h5.R&#39;) cohort_1.data &lt;- ReadCB_h5(&quot;./data/DemoSingle/Cohort_1_filtered.h5&quot;) The Read10X() function reads the output from the Cellranger pipeline by 10X Genomics, returning a unique molecular identifier (UMI) count matrix. In this matrix, the values represent the number of detected molecules for each feature (e.g., gene, row) in each cell (column). Note that while CellBender outputs are also in .h5 format, the Read10X_h5() function in Seurat is not compatible with CellBender (version 0.3.0). Therefore, we provide the custom ReadCB_h5 function below to handle this problem. 4.2 Setup the Seurat object # Initialize the Seurat object with the raw (non-normalized data) cohort_1 &lt;- CreateSeuratObject(counts = cohort_1.data, project = &quot;cohort_1&quot;, min.cells = 3, min.features = 200) cohort_1 # Add &#39;percent.mt&#39; column to object metadata cohort_1[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(cohort_1, pattern = &quot;^MT-&quot;) 4.3 Dection and handling of doublets/multiplets If you do not have the package, you may install the package using: BiocManager::install(&quot;scDblFinder&quot;) Given an object sce of class SingleCellExperiment (which has already had empty drops removed but hasn’t undergone further filtering), you can initiate doublet detection with the following command: sce &lt;- as.SingleCellExperiment(cohort_1) sce &lt;- scDblFinder(sce) doublets &lt;- as.data.frame(sce$scDblFinder.class) rownames(doublets) &lt;- colnames(sce) colnames(doublets) &lt;- &#39;type&#39; cohort_1@meta.data$doublet_type &lt;- doublets$type If you want to use other methods implemented in scDblFinder, you can refer to the vignette: https://github.com/plger/scDblFinder 4.4 Quality control and selecting cells for further analysis In this example, we visualize QC metrics, and use these to filter cells. 1.We filter cells that have unique counts over 200,000 or less than 500 2.We filter cells that have unique feature over 15,000 or less than 200 3.We filter cells that have &gt;5% mitochondrial counts # Visualize QC metrics as a violin plot VlnPlot(cohort_1, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3) ## FeatureScatter is typically used to visualize feature-feature relationships plot1 &lt;- FeatureScatter(cohort_1, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;percent.mt&quot;) plot2 &lt;- FeatureScatter(cohort_1, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;) plot1 + plot2 cohort_1 &lt;- subset(cohort_1, subset = nFeature_RNA &gt; 200 &amp; nFeature_RNA &lt; 15000 &amp; nCount_RNA &gt; 500 &amp; nCount_RNA &lt; 200000 &amp; percent.mt &lt; 5) cohort_1 &lt;- subset(cohort_1, subset = doublet_type == &#39;singlet&#39;) "],["normalization-clustering-and-annotation.html", "5 Normalization, clustering and annotation 5.1 Standard pre-processing workflow by applying sctransform normalization 5.2 Assigning cell type identity to clusters 5.3 Save the object", " 5 Normalization, clustering and annotation Gene-expression values were normalized using sctransform (v2). Principal component analysis (PCA) was carried out using the variable features for the SCT Assay Uniform Manifold Approximation and Projection (UMAP) analysis was performed to further reduce variation to two dimensions with ‘RunUMAP’ function with 25 to 40 principal components, and a resolution range from 0.6 to 2. These clusters were manually annotated based on differentially expressed genes generated from ‘FindAllMarkers’ function as well as the canonical marker genes from published literature. 5.1 Standard pre-processing workflow by applying sctransform normalization The sctransform function in Seurat consolidates the functionality of NormalizeData(), ScaleData(), and FindVariableFeatures() into a single command. The transformed data is stored in the SCT assay, which is set as the default assay after running sctransform. During normalization, it is possible to regress out confounding sources of variation, such as the percentage of mitochondrial reads. In Seurat v5, SCT v2 is applied by default, though you can revert to v1 by setting vst.flavor = ‘v1’. Additionally, the glmGamPoi package, which significantly enhances processing speed, is used by default if installed. You can find installation instructions here. In the same time, we perform dimensional reduction and genarates an ‘Elbow plot’ to find the majority of true signal captured in each PCs cohort_1 &lt;- SCTransform(cohort_1, vars.to.regress = &quot;percent.mt&quot;, verbose = FALSE) %&gt;% RunPCA(npcs = 75, verbose = FALSE) ElbowPlot(cohort_1, ndims = 50) To cluster the cells, we apply modularity optimization techniques, such as the Louvain algorithm (default), which iteratively group cells with the goal of optimizing the standard modularity function. The FindClusters() function in Seurat implements this procedure and includes a resolution parameter that controls the ‘granularity’ of clustering. Higher resolution values result in a greater number of clusters, providing finer distinctions between cell groups. cohort_1 &lt;- RunUMAP(cohort_1, reduction = &quot;pca&quot;, dims = 1:40, verbose = FALSE) %&gt;% FindNeighbors(reduction = &quot;pca&quot;, dims = 1:40, verbose = FALSE) %&gt;% FindClusters(resolution = 0.6, verbose = FALSE) DimPlot(cohort_1, label = T, repel = T) 5.2 Assigning cell type identity to clusters Fortunately in the case of the adipose tissue dataset, we can use canonical markers to easily match the unbiased clustering to known cell types: genes_to_check &lt;- c (&quot;CD3D&quot;, &quot;CD3E&quot;, &quot;PTPRC&quot;, &quot;CD4&quot;, &quot;CD2&quot;, &quot;CD40LG&quot;, &quot;IL7R&quot;, #Naive CD4 T &quot;KLRF1&quot;, &quot;PRF1&quot;, &quot;GZMB&quot;, &quot;KLRD1&quot;,#Cytotoxic CD8 T &quot;CD8A&quot;, &quot;GZMH&quot;, &quot;NKG7&quot;, #Naive CD8 T &quot;TIGIT&quot;, &quot;FOXP3&quot;, #Treg &quot;CCR6&quot;, &quot;KLRB1&quot;, &quot;CEBPD&quot;, #MAIT &quot;LEF1&quot;, &quot;KLRC2&quot;, &quot;ZNF683&quot;, #CD8 gd T &quot;GZMK&quot;, &quot;CCL5&quot;, &quot;XCL2&quot;, &quot;CCL4&quot;, #NK-like &quot;CX3CR1&quot;, &quot;GNLY&quot;, &quot;SPON2&quot;, #mNK &quot;KIT&quot;, &quot;CD200R1&quot;, #ILCs &quot;SMIM25&quot;, #ncMo &quot;S100A9&quot;, &quot;MMP19&quot;, #Monocyte &quot;S100A8&quot;, &quot;EREG&quot;, &quot;IL1B&quot;, #myeloid-like &quot;XCR1&quot;, &quot;CLEC9A&quot;, &quot;CADM1&quot;, #cDC1 &quot;CLEC10A&quot;, &quot;CD1C&quot;, &quot;FCER1A&quot;, #cDC2B &quot;IGKC&quot;, &quot;CD79A&quot;, #B cell &quot;C1QA&quot;, &quot;RNASE1&quot;, # PVMs &quot;MRC1&quot;, &quot;C1QB&quot;, &quot;CD86&quot;, #Macrophage &quot;DKK1&quot;, &quot;PI16&quot;, &quot;PRG4&quot;, &quot;DPP4&quot;,&quot;PDGFRA&quot;, #APC &quot;RGS5&quot;,&quot;MYH11&quot;, #SMC &amp; Pericyte &quot;CLDN5&quot;, &quot;VWF&quot;, &quot;PECAM1&quot;, #Endothelial &quot;PLIN1&quot;,&quot;PLIN4&quot;,&quot;ADIPOQ&quot;) #Adipocyte DotPlot(cohort_1, features = genes_to_check, cols = c(&quot;gray95&quot;, &quot;red&quot;), cluster.idents = T, col.min = 0, assay=&#39;SCT&#39;) + coord_flip() cohort_1@meta.data$major_celltype[cohort_1@meta.data$seurat_clusters %in% c(0,10,12)] &lt;- &#39;Adipocyte&#39; cohort_1@meta.data$major_celltype[cohort_1@meta.data$seurat_clusters %in% c(8,9)] &lt;- &#39;SMC&#39; cohort_1@meta.data$major_celltype[cohort_1@meta.data$seurat_clusters %in% 1] &lt;- &#39;Macrophage&#39; cohort_1@meta.data$major_celltype[cohort_1@meta.data$seurat_clusters %in% c(2,7)] &lt;- &#39;FAP&#39; cohort_1@meta.data$major_celltype[cohort_1@meta.data$seurat_clusters %in% 11] &lt;- &#39;T&#39; cohort_1@meta.data$major_celltype[cohort_1@meta.data$seurat_clusters %in% c(3,4,5,13)] &lt;- &#39;EC&#39; cohort_1@meta.data$major_celltype[cohort_1@meta.data$seurat_clusters %in% 6] &lt;- &#39;Monocyte&#39; cohort_1@meta.data$major_celltype[cohort_1@meta.data$seurat_clusters %in% 14] &lt;- &#39;ILC&#39; DimPlot(cohort_1, group.by = &#39;major_celltype&#39;) 5.3 Save the object saveRDS(cohort_1, file = &#39;./data/DemoSingle/Cohort_1_demo_annotated.rds&#39;) "],["data-integration.html", "6 Data integration 6.1 Library all the packages 6.2 Load all the objects used for batch-effect correction 6.3 Pre-processing before data integration 6.4 Peform analysis without integration 6.5 Perform integration 6.6 Visualition", " 6 Data integration After filtering, mitochondrial, ribosomal protein-coding and leukocyte antigen genes were removed from these 5 datasets. Batch effect were corrected by applying following integration tools: CCA and RPCA performed in the ‘IntegrateLayers’ function which is a streamlined integrative analysis from Seurat, Harmony as well as scVI(version 1.1.2). We used all genes in scVI integration, and Seurat objects were transcribed into anndata objects using scfetch (version 0.5.0) in R with reticulate (1.37.0). The integration of single-cell sequencing datasets—such as those from different experimental batches, donors, or conditions—is often a critical step in scRNA-seq workflows. Integrative analysis helps align shared cell types and states across datasets, enhancing statistical power and, more importantly, enabling accurate comparative analysis. In previous versions of Seurat, we introduced anchor-based integration methods to facilitate this process. Additionally, several labs have developed innovative tools for integration, including Harmony and scVI, which have proven to be powerful methods for scRNA-seq analysis. For more information, please refer to our vignette on integrating scRNA-seq data using multiple tools. 6.1 Library all the packages library(reticulate) library(scfetch) library(Seurat) library(SeuratData) library(harmony) library(dplyr) library(patchwork) library(sctransform) library(ggplot2) 6.2 Load all the objects used for batch-effect correction cohort_1 &lt;- readRDS(&#39;./data/DemoIntegrated/cohort_1_s.rds&#39;) cohort_2_s_1 &lt;- readRDS(&#39;./data/DemoIntegrated/cohort_2_s_1_s.rds&#39;) cohort_2_s_2 &lt;- readRDS(&#39;./data/DemoIntegrated/cohort_2_s_2_s.rds&#39;) cohort_3 &lt;- readRDS(&#39;./data/DemoIntegrated/cohort_3_s.rds&#39;) cohort_4_o_1 &lt;- readRDS(&#39;./data/DemoIntegrated/cohort_4_o_1_s.rds&#39;) cohort_4_o_2 &lt;- readRDS(&#39;./data/DemoIntegrated/cohort_4_o_2_s.rds&#39;) cohort_4_o_3 &lt;- readRDS(&#39;./data/DemoIntegrated/cohort_4_o_3_s.rds&#39;) cohort_4_o_4 &lt;- readRDS(&#39;./data/DemoIntegrated/cohort_4_o_4_s.rds&#39;) cohort_4_o_5 &lt;- readRDS(&#39;./data/DemoIntegrated/cohort_4_o_5_s.rds&#39;) 6.3 Pre-processing before data integration Add Donor ID as batch information cohort_1@meta.data$sampleid &lt;- &#39;ID1&#39; cohort_3@meta.data$sampleid &lt;- &#39;ID2&#39; cohort_2_s_1@meta.data$sampleid &lt;- &#39;ID3&#39; cohort_2_s_2@meta.data$sampleid &lt;- &#39;ID4&#39; cohort_4_o_1@meta.data$sampleid &lt;- &#39;ID5&#39; cohort_4_o_2@meta.data$sampleid &lt;- &#39;ID6&#39; cohort_4_o_3@meta.data$sampleid &lt;- &#39;ID7&#39; cohort_4_o_4@meta.data$sampleid &lt;- &#39;ID8&#39; cohort_4_o_5@meta.data$sampleid &lt;- &#39;ID9&#39; Create a object which contains multiple ‘layers’ to help to integrate all samples together, so that we can jointly identify cell subpopulations across datasets, and then explore how each group differs across conditions. NC_list &lt;- list(cohort_1, cohort_2_s_1, cohort_2_s_2, cohort_3, cohort_4_o_1, cohort_4_o_2, cohort_4_o_3, cohort_4_o_4, cohort_4_o_5) for (i in 1:length(NC_list)) { DefaultAssay(NC_list[[i]]) &lt;- &#39;RNA&#39; NC_list[[i]] &lt;- SCTransform(NC_list[[i]], vars.to.regress = &quot;percent.mt&quot;, verbose = FALSE) } NC_merged &lt;- merge(x = NC_list[[1]], y = NC_list[2:length(NC_list)]) In order to better identify the cell types, we plan to remove MT-/RP-/HLA- related genes before integration gene_mt &lt;- rownames(NC_merged)[grep(&quot;^MT-&quot;, rownames(NC_merged))] gene_rb &lt;- rownames(NC_merged)[grep(&quot;^RP[SL]&quot;, rownames(NC_merged))] gene_hla &lt;- rownames(NC_merged)[grep(&quot;^HLA-&quot;, rownames(NC_merged))] gene_rb &lt;- as.data.frame(gene_rb) gene_hla &lt;- as.data.frame(gene_hla) gene_mt &lt;- as.data.frame(gene_mt) gene &lt;- rownames(NC_merged) gene &lt;- as.data.frame(gene) gene$type &lt;- gene$gene %in% gene_rb$gene_rb gene &lt;- gene[gene$type == &quot;FALSE&quot;,] gene$type &lt;- gene$gene %in% gene_hla$gene_hla gene &lt;- gene[gene$type == &quot;FALSE&quot;,] gene$type &lt;- gene$gene %in% gene_mt$gene_mt gene &lt;- gene[gene$type == &quot;FALSE&quot;,] gene_list &lt;- gene$gene for (i in 1: length(NC_list)) { DefaultAssay(NC_list[[i]]) &lt;- &#39;RNA&#39; counts &lt;- GetAssayData(NC_list[[i]], layer = &#39;counts&#39;) counts &lt;- counts[rownames(counts) %in% gene_list, ] meta.data &lt;- NC_list[[i]]@meta.data NC_list[[i]] &lt;- CreateSeuratObject(counts = counts, meta.data = meta.data) NC_list[[i]] &lt;- SCTransform(NC_list[[i]], vars.to.regress = &quot;percent.mt&quot;, verbose = FALSE) } NC_merged &lt;- merge(NC_list[[1]], y = NC_list[2:length(NC_list)], merge.data = TRUE) NC_merged 6.4 Peform analysis without integration We begin by analyzing the dataset without performing integration to assess whether batch-effect correction is necessary. The resulting clusters are defined by both cell type and stimulation condition, which poses challenges for downstream analysis. DefaultAssay(NC_merged) &lt;- &#39;RNA&#39; NC_merged &lt;- SCTransform(NC_merged, verbose = T) NC_merged &lt;- RunPCA(NC_merged, npcs = 100, verbose = T) ElbowPlot(NC_merged, ndims = 50) NC_merged &lt;- RunUMAP(NC_merged, dims = 1:30, reduction = &quot;pca&quot;, reduction.name = &quot;unintegrated&quot;) DimPlot(NC_merged, reduction = &quot;unintegrated&quot;, group.by = &quot;sampleid&quot;) 6.5 Perform integration We now aim to integrate data from all the donors, so that cells from the same cell type/subpopulation will cluster together.For data integration, our goal is not to remove biological differences across conditions or different batches, but to learn shared cell types/states in an initial step - specifically because that will enable us to compare control stimulated and control profiles for these individual cell types. Seurat v5 supports a more streamlined integrated analysis through the use of the IntegrateLayers function. The current method supports five integration methods. Each of these methods performs integration in a low-dimensional space and returns a dimensionality reduction (i.e. integrated.rpca) designed to embed shared unit types across batches, here we use three of them: Anchor-based CCA integration (method=CCAIntegration) Anchor-based RPCA integration (method=RPCAIntegration) Harmony (method=HarmonyIntegration) 6.5.1 Anchor-based CCA integration The Seurat v5 integration procedure aims to return a single dimensional reduction that captures the shared sources of variance across multiple layers, so that cells in a similar biological state will cluster. The method returns a dimensional reduction (i.e. integrated.cca) which can be used for visualization and unsupervised clustering analysis. For evaluating performance, we can use cell type labels that are pre-loaded in the seurat_annotations metadata column. NC_merged &lt;- IntegrateLayers( object = NC_merged, method = CCAIntegration, normalization.method = &quot;SCT&quot;, verbose = FALSE) NC_merged &lt;- FindNeighbors(NC_merged, reduction = &quot;integrated.dr&quot;, dims = 1:30, verbose = FALSE) NC_merged &lt;- FindClusters(NC_merged, verbose = FALSE) NC_merged &lt;- RunUMAP(NC_merged, reduction = &quot;integrated.dr&quot;, dims = 1:30, reduction.name = &quot;cca&quot;, verbose = FALSE) 6.5.2 Anchor-based RPCA integration NC_merged &lt;- IntegrateLayers( object = NC_merged, method = RPCAIntegration, normalization.method = &quot;SCT&quot;, new.reduction = &quot;integrated.rpca&quot;, verbose = FALSE) NC_merged &lt;- FindNeighbors(NC_merged, reduction = &quot;integrated.rpca&quot;, dims = 1:30, verbose = FALSE) NC_merged &lt;- FindClusters(NC_merged, verbose = FALSE) NC_merged &lt;- RunUMAP(NC_merged, reduction = &quot;integrated.rpca&quot;, dims = 1:30, reduction.name = &quot;rpca&quot;, verbose = FALSE) 6.5.3 Harmony NC_merged &lt;- IntegrateLayers( object = NC_merged, method = HarmonyIntegration, normalization.method = &quot;SCT&quot;, new.reduction = &quot;integrated.harmony&quot;, verbose = FALSE) NC_merged &lt;- FindNeighbors(NC_merged, reduction = &quot;integrated.harmony&quot;, dims = 1:30, verbose = FALSE) NC_merged &lt;- FindClusters(NC_merged, verbose = FALSE) NC_merged &lt;- RunUMAP(NC_merged, reduction = &quot;integrated.harmony&quot;, dims = 1:30, reduction.name = &quot;harmony&quot;, verbose = FALSE) 6.5.4 scVI scvi-tools (single-cell variational inference tools) is a package for probabilistic modeling of single-cell omics data, built on top of PyTorch and AnnData. The package hosts implementations of several models that perform a wide range of single-cell data analysis tasks, as well as the building blocks to rapidly prototype new probabilistic models. For using scVI in R, scVI integration requires installing reticulate and scfetch as well as scvi-tools and its depencies in its environment. You can find the detailed instructions on the documentation: https://scvi-tools.org/get_started/ use_condaenv(&quot;~/miniconda3/envs/scvi&quot;, required=T) sc &lt;- import(&quot;scanpy&quot;, convert = FALSE) scvi &lt;- import(&quot;scvi&quot;, convert = FALSE) # prepare an anndata NC_merged@assays$SCT@data &lt;- NC_merged@assays$SCT@counts dim(NC_merged@assays$SCT@data) ExportSeurat(seu.obj = NC_merged, assay = &quot;SCT&quot;, to = &quot;AnnData&quot;, conda.path = &quot;~/miniconda3/envs/scvi&quot;, anndata.file = &quot;./data/DemoIntegrated/merged.h5ad&quot;) adata &lt;- sc$read(&#39;./data/DemoIntegrated/merged.h5ad&#39;) # run setup_anndata scvi$model$SCVI$setup_anndata(adata, batch_key = &#39;sampleid&#39;) model = scvi$model$SCVI(adata) # train the model model$train() # get the latent represention latent = model$get_latent_representation() # put it back in the original Seurat object latent &lt;- as.matrix(latent) rownames(latent) = colnames(NC_merged) NC_merged[[&quot;integrated.scvi&quot;]] &lt;- CreateDimReducObject(embeddings = latent, key = &quot;scvi_&quot;, assay = DefaultAssay(NC_merged)) NC_merged &lt;- FindNeighbors(NC_merged, reduction = &quot;integrated.scvi&quot;, dims = 1:10, verbose = FALSE) NC_merged &lt;- FindClusters(NC_merged, resolution = 0.6, verbose = FALSE) NC_merged &lt;- RunUMAP(NC_merged, dims = 1:10, reduction = &#39;integrated.scvi&#39;, reduction.name = &#39;scvi&#39;, verbose = FALSE) 6.5.5 scANVI # run setup_anndata model = scvi$model$SCANVI(adata) # train the model model$train() # get the latent represention latent = model$get_latent_representation() # put it back in the original Seurat object latent &lt;- as.matrix(latent) rownames(latent) = colnames(NC_merged) NC_merged[[&quot;integrated.scanvi&quot;]] &lt;- CreateDimReducObject(embeddings = latent, key = &quot;scanvi_&quot;, assay = DefaultAssay(NC_merged)) NC_merged &lt;- FindNeighbors(NC_merged, reduction = &quot;integrated.scanvi&quot;, dims = 1:10, verbose = FALSE) NC_merged &lt;- FindClusters(NC_merged, resolution = 0.6, verbose = FALSE) NC_merged &lt;- RunUMAP(NC_merged, dims = 1:10, reduction = &#39;integrated.scanvi&#39;, reduction.name = &#39;scanvi&#39;, verbose = FALSE) 6.6 Visualition reduction_name &lt;- c(&#39;unintegrated&#39;,&#39;rpca&#39;,&#39;cca&#39;,&#39;harmony&#39;,&#39;scvi&#39;,&#39;scanvi&#39;) for (i in 1:length(reduction_name)) { a &lt;- DimPlot(NC_merged, reduction = reduction_name[i], label = TRUE) + NoLegend() b &lt;- DimPlot(NC_merged, reduction = reduction_name[i], group.by = &quot;sampleid&quot;) c &lt;- DimPlot(NC_merged, reduction = reduction_name[i], group.by = &quot;celltype&quot;) print(a+b+c) } ## R version 4.3.2 (2023-10-31) ## Platform: x86_64-apple-darwin20 (64-bit) ## Running under: macOS Monterey 12.4 ## ## Matrix products: default ## BLAS: /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/lib/libRlapack.dylib; LAPACK version 3.11.0 ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## time zone: Asia/Shanghai ## tzcode source: internal ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## loaded via a namespace (and not attached): ## [1] deldir_2.0-4 pbapply_1.7-2 gridExtra_2.3 rlang_1.1.4 magrittr_2.0.3 RcppAnnoy_0.0.22 ## [7] spatstat.geom_3.3-3 matrixStats_1.4.1 ggridges_0.5.6 compiler_4.3.2 png_0.1-8 vctrs_0.6.5 ## [13] reshape2_1.4.4 stringr_1.5.1 pkgconfig_2.0.3 fastmap_1.2.0 utf8_1.2.4 promises_1.3.0 ## [19] rmarkdown_2.28 purrr_1.0.2 xfun_0.47 cachem_1.1.0 jsonlite_1.8.9 goftest_1.2-3 ## [25] highr_0.11 later_1.3.2 spatstat.utils_3.1-0 irlba_2.3.5.1 parallel_4.3.2 cluster_2.1.6 ## [31] R6_2.5.1 ica_1.0-3 bslib_0.8.0 spatstat.data_3.1-2 stringi_1.8.4 RColorBrewer_1.1-3 ## [37] reticulate_1.39.0 spatstat.univar_3.0-1 parallelly_1.38.0 jquerylib_0.1.4 lmtest_0.9-40 scattermore_1.2 ## [43] Rcpp_1.0.13 bookdown_0.40 knitr_1.48 tensor_1.5 future.apply_1.11.2 zoo_1.8-12 ## [49] sctransform_0.4.1 httpuv_1.6.15 Matrix_1.6-5 splines_4.3.2 igraph_2.0.3 tidyselect_1.2.1 ## [55] viridis_0.6.5 abind_1.4-8 rstudioapi_0.16.0 yaml_2.3.10 spatstat.random_3.3-2 codetools_0.2-20 ## [61] miniUI_0.1.1.1 spatstat.explore_3.3-2 listenv_0.9.1 lattice_0.22-6 tibble_3.2.1 plyr_1.8.9 ## [67] shiny_1.9.1 ROCR_1.0-11 evaluate_1.0.0 Rtsne_0.17 future_1.34.0 fastDummies_1.7.4 ## [73] survival_3.7-0 polyclip_1.10-7 fitdistrplus_1.2-1 pillar_1.9.0 Seurat_5.1.0 KernSmooth_2.23-24 ## [79] plotly_4.10.4 generics_0.1.3 RcppHNSW_0.6.0 sp_2.1-4 ggplot2_3.5.1 munsell_0.5.1 ## [85] scales_1.3.0 globals_0.16.3 xtable_1.8-4 glue_1.7.0 lazyeval_0.2.2 tools_4.3.2 ## [91] data.table_1.16.0 RSpectra_0.16-2 RANN_2.6.2 leiden_0.4.3.1 dotCall64_1.1-1 cowplot_1.1.3 ## [97] grid_4.3.2 tidyr_1.3.1 colorspace_2.1-1 nlme_3.1-166 patchwork_1.3.0 cli_3.6.3 ## [103] spatstat.sparse_3.1-0 spam_2.10-0 fansi_1.0.6 viridisLite_0.4.2 dplyr_1.1.4 uwot_0.2.2 ## [109] gtable_0.3.5 sass_0.4.9 digest_0.6.37 progressr_0.14.0 ggrepel_0.9.6 htmlwidgets_1.6.4 ## [115] SeuratObject_5.0.2 farver_2.1.2 htmltools_0.5.8.1 lifecycle_1.0.4 httr_1.4.7 mime_0.12 ## [121] MASS_7.3-60.0.1 "],["benchmarking-analyses.html", "7 Benchmarking analyses 7.1 Installation 7.2 Usage 7.3 More information", " 7 Benchmarking analyses In addition to identification of prominent marker genes in the integrated data, benchmarking included calculations of ARI coefficients, LISI scores kBET rates for integration across different donors by using benchmarking pipeline from scib-metrices (version 0.5.1) package. All the datasets were clustered well using the above method with refined resolution. We used the python package called scib that uses scanpy to streamline the integration of single-cell datasets and evaluate the results. The package contains several modules for preprocessing an anndata object, running integration methods and evaluating the resulting using a number of metrics. For preprocessing, scib.preprocessing (or scib.pp) contains functions for normalising, scaling or batch-aware selection of highly variable genes. Functions for the integration methods are in scib.integration or for short scib.ig and metrics are under scib.metrics (or scib.me). 7.1 Installation Install the latest release on PyPI. If you want to get more information, please refer to https://scib-metrics.readthedocs.io/en/stable/index.html pip install scib-metrics 7.2 Usage 7.2.1 Load and preprocess data import numpy as np import scanpy as sc import scvi from scib_metrics.benchmark import Benchmarker %matplotlib inline adata=sc.read(&#39;./data/DemoIntegrated/AT_integrated.h5ad&#39;) adata 7.2.2 Perform the benchmark bm = Benchmarker( adata, batch_key=&quot;sampleid&quot;, label_key=&quot;major_celltype&quot;, embedding_obsm_keys=[&quot;X_pca&quot;,&quot;X_integrated.dr&quot;,&quot;X_integrated.rpca&quot;,&quot;X_integrated.harmony&quot;, &quot;X_scvi&quot;, &quot;X_scanvi&quot;], n_jobs=6, ) bm.benchmark() 7.2.3 Visualize the results bm.plot_results_table(show=False) 7.3 More information If you want to get more information, please refer to the documentation and GitHub: https://scib-metrics.readthedocs.io/en/stable/index.html https://github.com/theislab/scib "],["reference.html", "8 Reference", " 8 Reference Massier, L., et al., An integrated single cell and spatial transcriptomic map of human white adipose tissue. Nature Communications, 2023. 14(1): p. 1438. Zheng, G. X. Y. et al. (2017). Massively parallel digital transcriptional profiling of single cells. Nature Communications 8: 1-12, doi:10.1038/ncomms14049 Fleming, S.J., et al., Unsupervised removal of systematic background noise from droplet-based single-cell experiments using CellBender. Nature Methods, 2023. 20(9): p. 1323-1335. Hao, Y., et al., Dictionary learning for integrative, multimodal and scalable single-cell analysis. Nature Biotechnology, 2024. 42(2): p. 293-304. Germain P, L.A., Garcia Meixide C, Macnair W, Robinson M Doublet identification in single-cell sequencing data using scDblFinder. f1000research, 2022. Hafemeister, C. and R. Satija, Normalization and variance stabilization of single-cell RNA-seq data using regularized negative binomial regression. Genome Biology, 2019. 20(1): p. 296. Aran, D., et al., Reference-based analysis of lung single-cell sequencing reveals a transitional profibrotic macrophage. Nature Immunology, 2019. 20(2): p. 163-172. Korsunsky, I., et al., Fast, sensitive and accurate integration of single-cell data with Harmony. Nature Methods, 2019. 16(12): p. 1289-1296. Luecken, M.D., et al., Benchmarking atlas-level data integration in single-cell genomics. Nature Methods, 2022. 19(1): p. 41-50. Yabing Song, J.G., Jianbin Wang, scfetch: an R package to access and format single-cell RNA sequencing datasets from public repositories. bioRxiv, 2023. Heumos, L., et al., Best practices for single-cell analysis across modalities. Nature Reviews Genetics, 2023. 24(8): p. 550-572. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
